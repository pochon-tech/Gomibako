#!/bin/bash

# Get the absolute path
# $0 で実行コマンドを取得
# dirname でベースディレクトリを取得
# サブシェル内で cd で移動
# pwd で絶対パスの取得
# echo $(cd $(dirname $0); pwd)

# Get a relative path
# echo $(dirname "$0")

# Shell特殊変数まとめ
# $#: コマンドラインの引数
# $1〜$9,$0: 引数それぞれ
# $*: $0 以外のコマンドライン引数
# $@: $* と同等。ただし "$@" とした時、位置パラメータを評価せずにコマンドに渡すことが出来る
# $?: シェルが最後に実行したコマンドの終了状態を保持している。ほとんどのコマンドは成功時には「０」を返す
# $$: 現在のシェルのプロセス番号を保持している
# $-: シェルにセットされているオプションを保持している
# $!: バックグラウンドで実行された直前のプロセスのプロセス番号を保持

# trapまとめ
# trap: 実行中のプロセスに対するシグナルを検知し、指定された処理を返すコマンド
#   シグナルを送出した際に、指定したコマンドを実行させる事ができる
#   trap [-lp] [[arg] sigspec ...] => trap 'コマンド' [シグナル番号|シグナル名] 
# シグナル: 実行中のプロセスに対して、特定のイベントを通知するために送出されるもの
#   よく使用されるのは、プロセスを終了するためのシグナルである SIGINT や SIGKILL
#   シグナル送出に良く利用するのは、kill コマンドと、ショートカットで利用する Ctrl + C
#   kill -9 [Pid]
#   ↑のコマンドは、プロセスの強制終了
#   -9はkillコマンドのオプションで、「SIGKILL」を意味
#   オプションを指定しないと-15「SIGTERM:プロセス終了シグナル」

# ----Start----

# このファイルの存在するディレクトリに移動する
cd $(dirname "$0")

# スクリプト終了時にサーバーを強制終了するシグナルハンドラを登録
# サーバを起動し，確実に準備が終わるように0.1秒待機する
# (apt install -y psmisc)
trap 'killall php' INT EXIT TERM HUP
php tcp-server.php & sleep 0.1 # & をつけると処理の終了を待たない

# クライアントを起動し，次にwaitするためにプロセスIDを集める
pids=()
for ((i = 0; i < 2; i++)) {
    php tcp-client.php & pids+=( $! ) # & をつけると処理の終了を待たない
}

# クライアントが全て終了するまで待つ
# wait: プロセスやジョブの終了を待つコマンド。バックグラウンドで複数のコマンドを実行し、全てが終了したら次の処理を行う」といった処理が可能
for ((i = 0; i < ${#pids[@]}; i++)) {
    wait ${pids[i]}
}